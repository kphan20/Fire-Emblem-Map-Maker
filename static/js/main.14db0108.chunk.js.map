{"version":3,"sources":["resources/Sacae1.png","components/utils.tsx","components/hotbar/hotbarSlice.ts","app/hooks.ts","components/tileset/tilesetSlice.ts","components/hotbar/Hotbar.tsx","components/tileset/Tileset.tsx","components/map_canvas/mapCanvasSlice.ts","components/map_canvas/MapCanvas.tsx","components/map_canvas/GridEditor.tsx","app/App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["TILE_SIZE","MAP_DIMENSIONS","createCell","style","className","convertSelectedToX","num","convertSelectedToY","Math","floor","hotbarSlice","createSlice","name","initialState","items","reducers","add","state","action","payload","length","includes","push","console","error","deleteItem","splice","clear","actions","selectItems","hotbar","useAppDispatch","useDispatch","useAppSelector","useSelector","tilesetSlice","selectedTile","selectedX","selectedY","select","selectSelectedTile","tileset","Hotbar","dispatch","map","element","backgroundPositionX","backgroundPositionY","onClick","id","Tileset","overlayGrid","y","x","top","right","width","height","margin","generateSelectionGrid","src","require","default","alt","grid","arr","i","gridGenerator","rows","cols","dragFill","mapCanvasSlice","changeGridTile","newGrid","addBottomRow","addTopRow","newRow","Array","fill","concat","addRightCol","addLeftCol","deleteRow","slice","deleteCol","toggleDragFill","selectGrid","mapCanvas","selectRows","selectCols","selectDragFill","MapCanvas","containerRef","useRef","useState","posX","changePosX","posY","changePosY","useEffect","zoomScale","changeScale","container","current","setProperty","mousePos","dragFillInit","dragStart","isDown","isDrag","minTop","maxTop","minLeft","maxLeft","scaledDivPos","getBoundingClientRect","boundChecker","min","max","check","mousedown","e","clientX","offsetLeft","clientY","offsetTop","numCols","parseInt","getPropertyValue","numRows","xDiff","window","visualViewport","yDiff","scaleFactor","colFactor","rowFactor","sign","bound","mousemoving","currentX","currentY","checkDragDistance","left","mouseup","x1","TILE_SCALE","y1","x2","y2","j","currRect","xCoord","yCoord","zoom","preventDefault","scale","deltaY","transform","addEventListener","removeEventListener","ref","offsetWidth","widthCalc","offsetHeight","heightCalc","GridEditor","rearrangeTiles","tileArray","rearrange","rowHolder","reverse","finalArr","forEach","row","mapTile","removePixel","substring","submit","a","results","props","data","mapData","fetch","mode","method","body","JSON","stringify","response","log","rowsForm","changeRowsForm","colsForm","changeColsForm","type","value","onChange","currentTarget","onBlur","changeGridRows","changeGridCols","App","tilesetVisible","toggleTileset","selectedStyle","store","configureStore","reducer","hotbarReducer","tilesetReducer","mapCanvasReducer","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.14db0108.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/Sacae1.0b274fdb.png\";","// Default size of tiles in tileset images\r\nexport const TILE_SIZE = 16;\r\n\r\n// Max size of hotbar\r\nexport const HOTBAR_SIZE = 8;\r\n\r\n// Default scaling of tile size on map editor\r\nexport const TILE_SCALE = 2;\r\n\r\n// Maximum distance moved before mouse movement is considered a mouse drag\r\nexport const DRAG_RADIUS = 0.01;\r\n\r\n// Size of tileset map\r\nexport const MAP_DIMENSIONS = 512;\r\n\r\n// Interface for style object\r\nexport interface MAP_TILE_STYLE {\r\n  backgroundPositionX: string;\r\n  backgroundPositionY: string;\r\n}\r\n\r\n/**\r\n * Generates map cell div\r\n * @param style Optional style object for generated div\r\n * @returns {JSX.Element}\r\n */\r\nexport const createCell = (style?: MAP_TILE_STYLE): JSX.Element => {\r\n  return <div className=\"cell\" style={style}></div>;\r\n};\r\n\r\n/**\r\n * Converts selected tile index to horizontal position in background tileset image\r\n * @param num tile index to be converted\r\n * @returns {number}\r\n */\r\nexport const convertSelectedToX = (num: number): number => {\r\n  return (num % (MAP_DIMENSIONS / TILE_SIZE)) * TILE_SIZE * TILE_SCALE;\r\n};\r\n\r\n/**\r\n * Converts selected tile index to vertical position in background tileset image\r\n * @param num tile index to be converted\r\n * @returns {number}\r\n */\r\nexport const convertSelectedToY = (num: number): number => {\r\n  return (\r\n    TILE_SCALE *\r\n    (MAP_DIMENSIONS -\r\n      TILE_SIZE -\r\n      Math.floor(num / (MAP_DIMENSIONS / TILE_SIZE)) * TILE_SIZE)\r\n  );\r\n};\r\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport { stat } from \"fs\";\r\nimport { RootState } from \"../../app/store\";\r\nimport { HOTBAR_SIZE } from \"../utils\";\r\n\r\n// Makes the hotbar state have an array that stores tile indices\r\nexport interface HotbarState {\r\n  items: number[];\r\n}\r\n\r\nconst initialState: HotbarState = {\r\n  items: [],\r\n};\r\n\r\nexport const hotbarSlice = createSlice({\r\n  name: \"hotbar\",\r\n  initialState,\r\n  reducers: {\r\n    // Adds tile index to hotbar if it's not full and the tile index not already included\r\n    add: (state, action: PayloadAction<number>) => {\r\n      if (action.payload < 0) return;\r\n      if (\r\n        state.items.length < HOTBAR_SIZE &&\r\n        !state.items.includes(action.payload)\r\n      ) {\r\n        state.items.push(action.payload);\r\n      } else {\r\n        console.error(\"Hotbar size exceeded\");\r\n      }\r\n    },\r\n    // Deletes hotbar item at specified index\r\n    deleteItem: (state, action: PayloadAction<number>) => {\r\n      state.items.splice(action.payload, 1);\r\n    },\r\n    // Deletes all hotbar items\r\n    clear: (state) => {\r\n      state.items = [];\r\n    },\r\n  },\r\n});\r\n\r\nexport const { add, deleteItem, clear } = hotbarSlice.actions;\r\n\r\n// Selector for items array\r\nexport const selectItems = (state: RootState) => state.hotbar.items;\r\n\r\nexport default hotbarSlice.reducer;\r\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport { RootState } from \"../../app/store\";\r\n\r\n// Makes selectedTile simply a numerical index\r\nexport interface tilesetState {\r\n  selectedTile: number;\r\n  selectedX: string;\r\n  selectedY: string;\r\n}\r\n\r\nconst initialState = {\r\n  selectedTile: -1,\r\n  selectedX: \"\",\r\n  selectedY: \"\",\r\n};\r\n\r\nexport const tilesetSlice = createSlice({\r\n  name: \"tileset\",\r\n  initialState,\r\n  reducers: {\r\n    // Changes selectedTile\r\n    select: (state, action: PayloadAction<number>) => {\r\n      state.selectedTile = action.payload;\r\n    },\r\n  },\r\n});\r\n\r\nexport const { select } = tilesetSlice.actions;\r\n\r\n// Selector of the selected tile\r\nexport const selectSelectedTile = (state: RootState) =>\r\n  state.tileset.selectedTile;\r\n\r\nexport default tilesetSlice.reducer;\r\n","import React from \"react\";\r\nimport { selectItems } from \"./hotbarSlice\";\r\nimport { HOTBAR_SIZE, convertSelectedToX, convertSelectedToY } from \"../utils\";\r\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\r\nimport { select } from \"../tileset/tilesetSlice\";\r\n\r\n// Represents tile hotbar for quicker tile selection\r\nexport default function Hotbar() {\r\n  // Gets current items in the hotbar\r\n  const items = useAppSelector(selectItems);\r\n  const dispatch = useAppDispatch();\r\n\r\n  // Creates hotbar div element array\r\n  const hotbar: JSX.Element[] = items.map((element) => {\r\n    // Correctly positions css sprites\r\n    const style = {\r\n      backgroundPositionX: `-${convertSelectedToX(element)}px`,\r\n      backgroundPositionY: `-${convertSelectedToY(element)}px`,\r\n    };\r\n    // Returns div element with onClick that changes current selected tile\r\n    return (\r\n      <div\r\n        className=\"hotbarCell\"\r\n        onClick={() => {\r\n          dispatch(select(element));\r\n        }}\r\n        style={style}\r\n      ></div>\r\n    );\r\n  });\r\n\r\n  // Pads until desired hotbar length is achieved\r\n  while (hotbar.length < HOTBAR_SIZE) {\r\n    hotbar.push(<div className=\"hotbarEmpty\"></div>);\r\n  }\r\n  return (\r\n    <div id=\"hotbar\" className=\"absolute\">\r\n      {hotbar}\r\n    </div>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport tilesetImage from \"../../resources/Sacae1.png\";\r\nimport { TILE_SIZE, MAP_DIMENSIONS } from \"../utils\";\r\nimport { select } from \"./tilesetSlice\";\r\nimport { useAppDispatch } from \"../../app/hooks\";\r\nimport \"./Tileset.css\";\r\n\r\n// Holds tileset palette and selection grid\r\nexport default function Tileset() {\r\n  // Holds divs responsible for selecting tiles on the tileset palette\r\n  const overlayGrid: JSX.Element[] = [];\r\n  const dispatch = useAppDispatch();\r\n\r\n  // Will hardcode in image dimensions until suitable method to find dimensions is found\r\n\r\n  /**\r\n   * Adds grid elements to overlay grid\r\n   */\r\n  const generateSelectionGrid = () => {\r\n    // 0-indexes tiles left to right, starting from the bottom row\r\n    for (let y = 0; y < MAP_DIMENSIONS; y += TILE_SIZE) {\r\n      for (let x = 0; x < MAP_DIMENSIONS; x += TILE_SIZE) {\r\n        const style = {\r\n          top: `${((MAP_DIMENSIONS - y - TILE_SIZE) / MAP_DIMENSIONS) * 100}%`,\r\n          right: `${\r\n            ((MAP_DIMENSIONS - x - TILE_SIZE) / MAP_DIMENSIONS) * 100\r\n          }%`,\r\n          width: `${TILE_SIZE}px`,\r\n          height: `${TILE_SIZE}px`,\r\n          margin: \"none\",\r\n        };\r\n        overlayGrid.push(\r\n          <div\r\n            className=\"tilesetSelection\"\r\n            style={style}\r\n            onClick={() => {\r\n              dispatch(\r\n                select(\r\n                  x / TILE_SIZE + ((y / TILE_SIZE) * MAP_DIMENSIONS) / TILE_SIZE\r\n                )\r\n              );\r\n              // console.log(\r\n              //   x / TILE_SIZE + ((y / TILE_SIZE) * MAP_DIMENSIONS) / TILE_SIZE\r\n              // );\r\n            }}\r\n          ></div>\r\n        );\r\n      }\r\n    }\r\n  };\r\n  generateSelectionGrid();\r\n  return (\r\n    <div id=\"tilesetContainer\">\r\n      {overlayGrid}\r\n      <img\r\n        src={require(`../../resources/Sacae1.png`).default}\r\n        alt=\"tilesetImage\"\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport { RootState } from \"../../app/store\";\r\nimport { createCell, MAP_TILE_STYLE } from \"../utils\";\r\n\r\n// Makes selectedTile simply a numerical index\r\nexport interface mapCanvasState {\r\n  grid: JSX.Element[];\r\n  rows: number;\r\n  cols: number;\r\n  dragFill: boolean;\r\n}\r\n\r\n/**\r\n * Creates map editor grid array\r\n * @param x number of rows\r\n * @param y number of columns\r\n * @returns {JSX.Element[]} array of map tile elements\r\n */\r\nconst gridGenerator = (x: number, y: number): JSX.Element[] => {\r\n  const arr = [];\r\n  for (let i = 0; i < x * y; i++) {\r\n    arr.push(createCell());\r\n  }\r\n  return arr;\r\n};\r\n\r\nconst initialState = {\r\n  grid: gridGenerator(3, 3),\r\n  rows: 3,\r\n  cols: 3,\r\n  dragFill: false,\r\n};\r\n\r\ninterface changeGridInterface {\r\n  id: number;\r\n  style: MAP_TILE_STYLE;\r\n}\r\n\r\nexport const mapCanvasSlice = createSlice({\r\n  name: \"mapCanvas\",\r\n  initialState,\r\n  reducers: {\r\n    // edits a tile in the grid\r\n    changeGridTile: (state, action: PayloadAction<changeGridInterface>) => {\r\n      const newGrid = [...state.grid];\r\n      newGrid[action.payload.id] = createCell(action.payload.style);\r\n      return { ...state, grid: newGrid };\r\n    },\r\n    // adds empty row to bottom of grid\r\n    addBottomRow: (state) => {\r\n      const newGrid = [...state.grid];\r\n      for (let i = 0; i < state.cols; i++) {\r\n        newGrid.push(createCell());\r\n      }\r\n      return { ...state, grid: newGrid, rows: state.rows + 1 };\r\n    },\r\n    // adds empty row to top\r\n    addTopRow: (state) => {\r\n      const newRow = Array(state.cols).fill(createCell());\r\n      return {\r\n        ...state,\r\n        grid: newRow.concat(state.grid),\r\n        rows: state.rows + 1,\r\n      };\r\n    },\r\n    // adds empty column to right\r\n    addRightCol: (state) => {\r\n      const newGrid = [...state.grid];\r\n      // downside of using flattened grid array - splice may not be very efficient\r\n      for (let i = 1; i < state.rows; i++) {\r\n        newGrid.splice(i * (state.cols + 1) - 1, 0, createCell());\r\n      }\r\n      newGrid.push(createCell());\r\n      return { ...state, grid: newGrid, cols: state.cols + 1 };\r\n    },\r\n    // adds empty column to left\r\n    addLeftCol: (state) => {\r\n      const newGrid = [...state.grid];\r\n      for (let i = 0; i < state.rows; i++) {\r\n        newGrid.splice(i * (state.cols + 1), 0, createCell());\r\n      }\r\n      return { ...state, grid: newGrid, cols: state.cols + 1 };\r\n    },\r\n    // deletes bottom row by default - may implement top row deletion later\r\n    deleteRow: (state) => {\r\n      const newGrid = state.grid.slice(0, state.grid.length - state.cols);\r\n      return { ...state, grid: newGrid, rows: state.rows - 1 };\r\n    },\r\n    // deletes right column by default\r\n    deleteCol: (state) => {\r\n      const newGrid = [...state.grid];\r\n      for (let i = newGrid.length - 1; i >= 0; i -= state.cols) {\r\n        newGrid.splice(i, 1);\r\n      }\r\n      return { ...state, grid: newGrid, cols: state.cols - 1 };\r\n    },\r\n    toggleDragFill: (state) => {\r\n      return { ...state, dragFill: !state.dragFill };\r\n    },\r\n  },\r\n});\r\n\r\nexport const {\r\n  changeGridTile,\r\n  addBottomRow,\r\n  addTopRow,\r\n  addLeftCol,\r\n  addRightCol,\r\n  deleteRow,\r\n  deleteCol,\r\n  toggleDragFill,\r\n} = mapCanvasSlice.actions;\r\n\r\n// Selector of the grid\r\nexport const selectGrid = (state: RootState) => state.mapCanvas.grid;\r\n// Selector of the number of rows\r\nexport const selectRows = (state: RootState) => state.mapCanvas.rows;\r\n// Selector of the number of columns\r\nexport const selectCols = (state: RootState) => state.mapCanvas.cols;\r\n// Selector of drag fill boolean\r\nexport const selectDragFill = (state: RootState) => state.mapCanvas.dragFill;\r\n\r\nexport default mapCanvasSlice.reducer;\r\n","import React, { useState, useEffect, useRef } from \"react\";\r\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\r\nimport { selectSelectedTile } from \"../tileset/tilesetSlice\";\r\nimport {\r\n  selectCols,\r\n  selectRows,\r\n  selectGrid,\r\n  selectDragFill,\r\n  changeGridTile,\r\n} from \"./mapCanvasSlice\";\r\nimport {\r\n  TILE_SIZE,\r\n  TILE_SCALE,\r\n  DRAG_RADIUS,\r\n  convertSelectedToX,\r\n  convertSelectedToY,\r\n} from \"../utils\";\r\nexport default function MapCanvas() {\r\n  // Contains dom reference for the map tile container\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  // redux components\r\n  const dispatch = useAppDispatch();\r\n  const rows = useAppSelector(selectRows);\r\n  const cols = useAppSelector(selectCols);\r\n  const grid = useAppSelector(selectGrid);\r\n  // Used to determine whether drag clicks should fill tile editor\r\n  const dragFill = useAppSelector(selectDragFill);\r\n  const selectedTile = useAppSelector(selectSelectedTile);\r\n\r\n  // Stores x and y background position of selected tile\r\n  const [posX, changePosX] = useState<string>();\r\n  const [posY, changePosY] = useState<string>();\r\n\r\n  useEffect(() => {\r\n    changePosX(`-${convertSelectedToX(selectedTile)}px`);\r\n    changePosY(`-${convertSelectedToY(selectedTile)}px`);\r\n  }, [selectedTile]);\r\n\r\n  // Stores the zoom scale of the map editor between renders\r\n  const [zoomScale, changeScale] = useState(1);\r\n\r\n  // Detects mouse inputs and changes map editor accordingly\r\n  useEffect(() => {\r\n    const container = containerRef.current!;\r\n    // Resizes grid upon changes in dimensions\r\n    container.style.setProperty(\"--rows\", `${rows}`);\r\n    container.style.setProperty(\"--columns\", `${cols}`);\r\n    container.style.setProperty(\"--tilesize\", `${TILE_SIZE * TILE_SCALE}px`);\r\n\r\n    // tracks current mouse position [x, y]\r\n    let mousePos = [0, 0];\r\n\r\n    // tracks initial drag point for drag fill\r\n    let dragFillInit = [0, 0];\r\n\r\n    // used to determine whether a drag action has occurred\r\n    let dragStart = [0, 0];\r\n\r\n    // used to check whether the left mouse button is held down\r\n    let isDown = false;\r\n\r\n    // flag to check whether the container is being dragged or not\r\n    let isDrag = false;\r\n\r\n    // used to ensure container is not dragged outside of viewport\r\n    let minTop = 0;\r\n    let maxTop = 0;\r\n    let minLeft = 0;\r\n    let maxLeft = 0;\r\n\r\n    // Used to get position relative to container div (for drag fill logic)\r\n    const scaledDivPos = container.getBoundingClientRect();\r\n\r\n    /**\r\n     * Checks if a number is within bounds\r\n     * @param min   Lower bound\r\n     * @param max   Upper bound\r\n     * @param check Examined number\r\n     * @returns {number} Returns the one of the bounds or the number\r\n     */\r\n    const boundChecker = (min: number, max: number, check: number): number => {\r\n      if (check < min) {\r\n        return min;\r\n      }\r\n      if (check > max) {\r\n        return max;\r\n      }\r\n      return check;\r\n    };\r\n\r\n    /**\r\n     * Checks if the drag distance is greater than the radius constant\r\n     * @param xDiff change in x\r\n     * @param yDiff change in y\r\n     * @returns {boolean} whether the container is being dragged or not\r\n     */\r\n    const checkDragDistance = (xDiff: number, yDiff: number): boolean => {\r\n      return xDiff ** 2 + yDiff ** 2 > DRAG_RADIUS;\r\n    };\r\n\r\n    // Handles beginning of click\r\n    const mousedown = (e: MouseEvent) => {\r\n      // Sets initial mouse position (relative to the change in container position)\r\n      mousePos = dragStart = [\r\n        e.clientX - container.offsetLeft,\r\n        e.clientY - container.offsetTop,\r\n      ];\r\n\r\n      // Sets initial mouse position (relative to inside of container)\r\n      dragFillInit = [e.clientX - scaledDivPos.x, e.clientY - scaledDivPos.y];\r\n\r\n      // Ensures other mouse functions don't trigger accidentally\r\n      isDown = true;\r\n\r\n      // Logic to determine bounds when moving the map editor\r\n      const numCols = parseInt(container.style.getPropertyValue(\"--columns\"));\r\n      const numRows = parseInt(container.style.getPropertyValue(\"--rows\"));\r\n      const xDiff =\r\n        window.visualViewport.width - numCols * TILE_SCALE * TILE_SIZE;\r\n      const yDiff =\r\n        window.visualViewport.height - numRows * TILE_SCALE * TILE_SIZE;\r\n\r\n      // scaleFactor determined after extensive experimentation\r\n      // complexity may be due to uncertainty with how offset measurements\r\n      // are given - offset left/top just did not give the correct\r\n      // measurements when scale was greater than 1\r\n      const scaleFactor = TILE_SIZE * (zoomScale - 1);\r\n      const colFactor = numCols * scaleFactor;\r\n      const rowFactor = numRows * scaleFactor;\r\n      let sign = xDiff >= 0 ? 1 : -1;\r\n      let bound = xDiff - sign * colFactor;\r\n      minLeft = Math.min(sign * colFactor, bound);\r\n      maxLeft = Math.max(sign * colFactor, bound);\r\n      sign = yDiff >= 0 ? 1 : -1;\r\n      bound = yDiff - sign * rowFactor;\r\n      minTop = Math.min(sign * rowFactor, bound);\r\n      maxTop = Math.max(sign * rowFactor, bound);\r\n    };\r\n\r\n    // Handles movement of mouse\r\n    const mousemoving = (e: MouseEvent) => {\r\n      if (!isDown) {\r\n        return;\r\n      }\r\n\r\n      // Gets current mouse position\r\n      mousePos = [\r\n        e.clientX - container.offsetLeft,\r\n        e.clientY - container.offsetTop,\r\n      ];\r\n\r\n      // Gets current position of container\r\n      let currentX = container.offsetLeft; //removePixel(container.style.left) || 0;\r\n      let currentY = container.offsetTop; //removePixel(container.style.top) || 0;\r\n\r\n      // Calcs change in position\r\n      const xDiff = mousePos[0] - dragStart[0];\r\n      const yDiff = mousePos[1] - dragStart[1];\r\n      currentX += xDiff;\r\n      currentY += yDiff;\r\n\r\n      // If the position changed beyond some radius, toggle isDrag\r\n      if (checkDragDistance(xDiff, yDiff)) {\r\n        isDrag = true;\r\n      }\r\n      if (!dragFill) {\r\n        // Moves container within bounds\r\n        currentX = boundChecker(minLeft, maxLeft, currentX);\r\n        currentY = boundChecker(minTop, maxTop, currentY);\r\n        container.style.left = `${currentX}px`;\r\n        container.style.top = `${currentY}px`;\r\n      }\r\n    };\r\n\r\n    // Handles mouse release\r\n    const mouseup = (e: MouseEvent) => {\r\n      if (!isDown) return;\r\n      isDown = false;\r\n\r\n      // If the mouse wasn't dragged, place a tile in the map editor\r\n      if (!isDrag) {\r\n        // Checks if there is a valid tile selected\r\n        if (selectedTile > -1) {\r\n          const currRect = container.getBoundingClientRect();\r\n          let xCoord = e.clientX - currRect.x;\r\n          let yCoord = e.clientY - currRect.y;\r\n          xCoord = Math.floor(xCoord / (TILE_SCALE * TILE_SIZE * zoomScale));\r\n          yCoord = Math.floor(yCoord / (TILE_SCALE * TILE_SIZE * zoomScale));\r\n          const payload = {\r\n            id: yCoord * cols + xCoord,\r\n            style: { backgroundPositionX: posX!, backgroundPositionY: posY! },\r\n          };\r\n          dispatch(changeGridTile(payload));\r\n        }\r\n      } else if (dragFill) {\r\n        // Fills in the selected squares\r\n        let x1 = Math.floor(\r\n          dragFillInit[0] / (TILE_SCALE * TILE_SIZE * zoomScale)\r\n        );\r\n        let y1 = Math.floor(\r\n          dragFillInit[1] / (TILE_SCALE * TILE_SIZE * zoomScale)\r\n        );\r\n        let x2 = Math.floor(\r\n          (e.clientX - scaledDivPos.x) / (TILE_SCALE * TILE_SIZE * zoomScale)\r\n        );\r\n        let y2 = Math.floor(\r\n          (e.clientY - scaledDivPos.y) / (TILE_SCALE * TILE_SIZE * zoomScale)\r\n        );\r\n        const style = {\r\n          backgroundPositionX: posX!,\r\n          backgroundPositionY: posY!,\r\n        };\r\n        for (let i = Math.min(x1, x2); i <= Math.max(x1, x2); i++) {\r\n          for (let j = Math.min(y1, y2); j <= Math.max(y1, y2); j++) {\r\n            if (j > rows - 1 || i > cols - 1) break;\r\n            dispatch(changeGridTile({ id: j * cols + i, style: style }));\r\n          }\r\n        }\r\n      }\r\n      isDrag = false;\r\n    };\r\n\r\n    // Handles scroll wheel zoom in container\r\n    const zoom = (e: WheelEvent) => {\r\n      e.preventDefault();\r\n      let scale = zoomScale;\r\n      scale += e.deltaY * -0.01;\r\n      // Limits zoom in between 1 and 4\r\n      scale = Math.min(Math.max(1, scale), 4);\r\n      container.style.transform = `scale(${scale})`;\r\n      changeScale(scale);\r\n    };\r\n\r\n    container.addEventListener(\"mousedown\", mousedown);\r\n    container.addEventListener(\"mousemove\", mousemoving);\r\n    container.addEventListener(\"mouseup\", mouseup);\r\n    container.addEventListener(\"wheel\", zoom);\r\n    window.addEventListener(\"mouseup\", mouseup);\r\n    // Clean up\r\n    return () => {\r\n      container.removeEventListener(\"mousedown\", mousedown);\r\n      container.removeEventListener(\"mousemove\", mousemoving);\r\n      container.removeEventListener(\"mouseup\", mouseup);\r\n      container.removeEventListener(\"wheel\", zoom);\r\n      window.removeEventListener(\"mouseup\", mouseup);\r\n    };\r\n  }, [posX, posY, rows, cols, zoomScale, dragFill]);\r\n\r\n  /**\r\n   * Brings the map back into a more centralized view\r\n   */\r\n  const recenter = () => {\r\n    const container = containerRef.current!;\r\n    // if width of map is less than the screen's, center it\r\n    // otherwise, bring map to left edge\r\n    const width = container.offsetWidth;\r\n    const winWidth = window.visualViewport.width;\r\n    const widthCalc = width < winWidth ? `calc(50vw - ${width / 2}px)` : \"0px\";\r\n    container.style.left = widthCalc;\r\n    // similar logic to width\r\n    const height = container.offsetHeight;\r\n    const winHeight = window.visualViewport.height;\r\n    const heightCalc =\r\n      height < winHeight ? `calc(50vh - ${height / 2}px)` : \"0px\";\r\n    container.style.top = heightCalc;\r\n  };\r\n  return (\r\n    <>\r\n      <div id=\"container\" className=\"absolute\" ref={containerRef}>\r\n        {grid}\r\n      </div>\r\n      <button id=\"recenter\" className=\"absolute\" onClick={recenter}>\r\n        Recenter Map\r\n      </button>\r\n    </>\r\n  );\r\n}\r\n","import { useState, useEffect } from \"react\";\r\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\r\nimport { MAP_DIMENSIONS, TILE_SCALE, TILE_SIZE } from \"../utils\";\r\nimport {\r\n  selectGrid,\r\n  selectRows,\r\n  selectCols,\r\n  addBottomRow,\r\n  addTopRow,\r\n  addRightCol,\r\n  addLeftCol,\r\n  toggleDragFill,\r\n  deleteRow,\r\n  deleteCol,\r\n} from \"./mapCanvasSlice\";\r\n\r\nexport default function GridEditor() {\r\n  const dispatch = useAppDispatch();\r\n  const grid = useAppSelector(selectGrid);\r\n  const rows = useAppSelector(selectRows);\r\n  const cols = useAppSelector(selectCols);\r\n\r\n  /**\r\n   * Rearranges map editor array so that the tiles are listed from bottom to top, left to right\r\n   * @param tileArray array of map tile elements\r\n   * @returns {JSX.Element[]} rearranged array\r\n   */\r\n  const rearrangeTiles = (tileArray: JSX.Element[]): JSX.Element[] => {\r\n    const rearrange = [];\r\n    let rowHolder = [];\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < cols; j++) {\r\n        rowHolder.push(tileArray[i * cols + j]);\r\n      }\r\n      rearrange.push(rowHolder);\r\n      rowHolder = [];\r\n    }\r\n    rearrange.reverse();\r\n    const finalArr: JSX.Element[] = [];\r\n    rearrange.forEach((row) => {\r\n      row.forEach((mapTile) => {\r\n        finalArr.push(mapTile);\r\n      });\r\n    });\r\n    return finalArr;\r\n  };\r\n\r\n  /**\r\n   * Converts position of css sprite to selected tile index\r\n   * @param x horizontal position of tile\r\n   * @param y vertical position of tile\r\n   * @returns {number}\r\n   */\r\n  const convertPositionToSelected = (x: number, y: number): number => {\r\n    const newX = -x / (TILE_SCALE * TILE_SIZE);\r\n    const newY = (y / TILE_SCALE + MAP_DIMENSIONS - TILE_SIZE) / TILE_SIZE;\r\n    return newX + newY * (MAP_DIMENSIONS / TILE_SIZE);\r\n  };\r\n\r\n  /**\r\n   * Converts string with pixel measurement to number\r\n   * @param length String with px attached to number (i.e. 30px)\r\n   * @returns {number} Number without px\r\n   */\r\n  const removePixel = (length: string): number => {\r\n    return parseInt(length.substring(0, length.length - 2));\r\n  };\r\n\r\n  // Handles map submission\r\n  const submit = async () => {\r\n    const arr = rearrangeTiles(grid!);\r\n    const results = [];\r\n    for (let i = 0; i < arr.length; i++) {\r\n      const style = arr[i].props.style;\r\n      try {\r\n        results.push(\r\n          convertPositionToSelected(\r\n            removePixel(style.backgroundPositionX),\r\n            removePixel(style.backgroundPositionY)\r\n          )\r\n        );\r\n      } catch (error) {\r\n        // produce error message\r\n        return;\r\n      }\r\n    }\r\n    //fs.writeFile(\"test.json\", JSON.stringify(results));\r\n    const data = {\r\n      rows: rows,\r\n      cols: cols,\r\n      mapData: results,\r\n    };\r\n    const response = await fetch(\"http://127.0.0.1:3000\", {\r\n      mode: \"cors\",\r\n      method: \"POST\",\r\n      body: JSON.stringify(data),\r\n    });\r\n    // console.log(JSON.stringify(results));\r\n    // let element = document.createElement(\"a\");\r\n    // element.setAttribute(\r\n    //   \"href\",\r\n    //   \"data:text/plain;charset=utf-8,\" +\r\n    //     encodeURIComponent(`${cols},${rows},${JSON.stringify(results)}`)\r\n    // );\r\n    // element.setAttribute(\"download\", \"test.txt\");\r\n    // element.style.display = \"none\";\r\n    // document.body.appendChild(element);\r\n    // element.click();\r\n    // document.body.removeChild(element);\r\n    console.log(response);\r\n    return response;\r\n  };\r\n\r\n  // Controls input elements editing row and column number\r\n  const [rowsForm, changeRowsForm] = useState(rows);\r\n  const [colsForm, changeColsForm] = useState(cols);\r\n\r\n  // automatically updates input values when dimensions change\r\n  // ideally, finding a way to use the rows state for the form\r\n  // would be nice but changeGridRows/Cols would be affected\r\n  useEffect(() => {\r\n    changeRowsForm(rows);\r\n    changeColsForm(cols);\r\n  }, [rows, cols]);\r\n\r\n  /**\r\n   * Changes number of rows in grid, adding or deleting starting from the bottom\r\n   * @param x new number of rows\r\n   * @returns\r\n   */\r\n  const changeGridRows = (x: number) => {\r\n    if (!x) return;\r\n    if (rows < x) {\r\n      for (let i = 0; i < x - rows; i++) {\r\n        dispatch(addBottomRow());\r\n      }\r\n    } else if (rows > x) {\r\n      for (let i = rows; i > x; i--) {\r\n        dispatch(deleteRow());\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Changes number of columns in grid, adding or deleting starting from the right\r\n   * @param y new number of columns\r\n   */\r\n  const changeGridCols = (y: number) => {\r\n    if (!y) return;\r\n    if (cols < y) {\r\n      for (let i = 0; i < y - cols; i++) {\r\n        dispatch(addRightCol());\r\n      }\r\n    } else if (cols > y) {\r\n      for (let i = cols; i > y; i--) {\r\n        dispatch(deleteCol());\r\n      }\r\n    }\r\n  };\r\n  return (\r\n    <>\r\n      <div id=\"gridEditors\" className=\"absolute\">\r\n        <button\r\n          id=\"addBottomRow\"\r\n          className=\"gridEditor\"\r\n          onClick={() => dispatch(addBottomRow())}\r\n        >\r\n          Add Bottom row\r\n        </button>\r\n        <button\r\n          id=\"addTopRow\"\r\n          className=\"gridEditor\"\r\n          onClick={() => dispatch(addTopRow())}\r\n        >\r\n          Add Top Row\r\n        </button>\r\n        <button\r\n          id=\"addRightCol\"\r\n          className=\"gridEditor\"\r\n          onClick={() => dispatch(addRightCol())}\r\n        >\r\n          Add Right Col\r\n        </button>\r\n        <button\r\n          id=\"addLeftCol\"\r\n          className=\"gridEditor\"\r\n          onClick={() => dispatch(addLeftCol())}\r\n        >\r\n          Add Left Col\r\n        </button>\r\n        <button id=\"submit\" className=\"gridEditor\" onClick={submit}>\r\n          Submit\r\n        </button>\r\n        <button\r\n          id=\"toggleDragFill\"\r\n          className=\"gridEditor\"\r\n          onClick={() => dispatch(toggleDragFill())}\r\n        >\r\n          Drag Fill\r\n        </button>\r\n      </div>\r\n\r\n      <div id=\"sizeInput\" className=\"absolute\">\r\n        <span>Rows:</span>\r\n        <input\r\n          id=\"rowChange\"\r\n          className=\"gridEditor\"\r\n          type=\"number\"\r\n          min=\"0\"\r\n          max=\"50\"\r\n          value={rowsForm}\r\n          onChange={(e) => changeRowsForm(parseInt(e.currentTarget.value))}\r\n          onBlur={(e) => changeGridRows(parseInt(e.currentTarget.value))}\r\n        />\r\n        <br></br>\r\n        <span>Columns:</span>\r\n        <input\r\n          id=\"colsChange\"\r\n          className=\"gridEditor\"\r\n          type=\"number\"\r\n          min=\"0\"\r\n          max=\"50\"\r\n          value={colsForm}\r\n          onChange={(e) => changeColsForm(parseInt(e.currentTarget.value))}\r\n          onBlur={(e) => changeGridCols(parseInt(e.currentTarget.value))}\r\n        />\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n","import React, { useState } from \"react\";\r\nimport \"./App.css\";\r\nimport Hotbar from \"../components/hotbar/Hotbar\";\r\nimport { add, clear } from \"../components/hotbar/hotbarSlice\";\r\nimport Tileset from \"../components/tileset/Tileset\";\r\nimport MapCanvas from \"../components/map_canvas/MapCanvas\";\r\nimport GridEditor from \"../components/map_canvas/GridEditor\";\r\nimport { useAppDispatch, useAppSelector } from \"./hooks\";\r\nimport { selectSelectedTile } from \"../components/tileset/tilesetSlice\";\r\nimport {\r\n  TILE_SCALE,\r\n  TILE_SIZE,\r\n  convertSelectedToX,\r\n  convertSelectedToY,\r\n} from \"../components/utils\";\r\n\r\n// Upper level container for app features\r\nexport default function App() {\r\n  // Used to toggle whether or not the tileset palette is visible\r\n  const [tilesetVisible, toggleTileset] = useState(true);\r\n\r\n  // Calls typed useDispatch from hooks.ts\r\n  const dispatch = useAppDispatch();\r\n\r\n  // Stores the current selected tile from the tileset\r\n  const selectedTile = useAppSelector(selectSelectedTile);\r\n\r\n  // Contains the initial styling object for the selected tile display\r\n  const selectedStyle = {\r\n    height: `${TILE_SIZE * TILE_SCALE}`,\r\n    width: `${TILE_SIZE * TILE_SCALE}`,\r\n    backgroundPositionX: `-${convertSelectedToX(selectedTile)}px`,\r\n    backgroundPositionY: `-${convertSelectedToY(selectedTile)}px`,\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div id=\"tileset\" className=\"absolute\">\r\n        <button\r\n          id=\"toggleTileset\"\r\n          onClick={() => toggleTileset(!tilesetVisible)}\r\n        >\r\n          {tilesetVisible ? \">\" : \"<\"}\r\n        </button>\r\n        {tilesetVisible && <Tileset />}\r\n      </div>\r\n      <GridEditor />\r\n      <MapCanvas />\r\n      <div id=\"hotbarOptions\" className=\"absolute\">\r\n        <button id=\"hotbarAdd\" onClick={() => dispatch(add(selectedTile))}>\r\n          Add selected to hotbar\r\n        </button>\r\n        <button id=\"hotbarClear\" onClick={() => dispatch(clear())}>\r\n          Clear\r\n        </button>\r\n      </div>\r\n      <div id=\"selectedTile\" className=\"absolute\" style={selectedStyle}></div>\r\n      <Hotbar />\r\n    </>\r\n  );\r\n}\r\n","import { configureStore } from \"@reduxjs/toolkit\";\r\nimport hotbarReducer from \"../components/hotbar/hotbarSlice\";\r\nimport tilesetReducer from \"../components/tileset/tilesetSlice\";\r\nimport mapCanvasReducer from \"../components/map_canvas/mapCanvasSlice\";\r\n\r\nexport const store = configureStore({\r\n  reducer: {\r\n    hotbar: hotbarReducer,\r\n    tileset: tilesetReducer,\r\n    mapCanvas: mapCanvasReducer,\r\n  },\r\n});\r\n\r\nexport type AppDispatch = typeof store.dispatch;\r\nexport type RootState = ReturnType<typeof store.getState>;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./app/App\";\r\nimport { store } from \"./app/store\";\r\nimport { Provider } from \"react-redux\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}